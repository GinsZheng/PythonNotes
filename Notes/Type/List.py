# 列表没有固定类型的约束
# 大多数列表方法是直接改变列表，而不像字符串那样新建一个对象
# 调用不存在的元素会报错，如只有3个元素的M表，调用M[99]会报错
# 列表可嵌套，二维列表可这样调用：M[0][0]

# 创建
L = list('spam') # 转换成列表
print(L)  # ➤ ['s', 'p', 'a', 'm']
L = list(range(-4,4))
print(L) # ➤ [-4, -3, -2, -1, 0, 1, 2, 3] | 连续整数

# 调用
x = [123,'spam',1.23]
print(x[0]) # ➤ 123


# 编辑
# 在特定位置插入一个值
L = [1, 2, 3]
L.insert(1,9) # 1为下标
print("编辑在特定位置插入一个值", L) # 插入的值把其他值往后挤

# 修改特定下标的项
L = [-4, -3, -2, -1, 0, 1, 2, 3]
L[1:4] = ['a','b'] # 索引修改相当于把原有的东西去掉再添加任意个数，因此前后可以个数不同
print("修改特定下标的项", L)

# 在最后位置增加一项
L.append('z') # 增加在最后
print("在最后位置增加一项", L)
L += ['x']  # 也是在最后位置增加一项

# 在最后位置增加多项
L = ['a', 'b']
L.extend(['c','d'])
print("在最后位置增加多项", L)


# 删除
# 删除最后一项(常用于栈)
L = ['a', 'b', 'c', 'd']
print("删除最后一项(常用于栈), 获取删除值", L.pop()) # ➤ 'd' | pop有两个动作：把最后一个元素提取出来，同时删除它在列表中的存在(删除并返回值)
print("删除最后一项(常用于栈), 获取删除后列表", L) # ➤ ['a', 'b', 'c']
L.append('f') # pop()与append()联用，来实现堆栈结构

# 删除特定下标的多项
L = ['a', 'b', 'c', 'd']
L[1:4] = []
print("删除特定下标的多项", L)

# 删除特定下标的多项(方法2)
L = ['a', 'b', 'c', 'd']
del L[1:]
print("删除特定下标的多项(方法2)", L)

# 删除特定下标的一项
L = ['a', 'b', 'c', 'd']
print("删除特定下标的一项", L.pop(1), L)

# 删除特定下标的一项(方法2)
L = ['a', 'b', 'c', 'd']
del L[0]
print("删除特定下标的一项(方法2)", L)

# 删除特定值的一项
L = ['a', 'b', 'c', 'd']
L.remove('c')
print("删除特定值的一项", L)


# 获取下标
L = [1, 2, 3]
print("获取下标", L.index(1))  # ➤ 0  

